<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>easyprint</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>easyprint</h1>
          <h3>Stringify your C++ STL containers, with ease</h3>
          <p>
            <small>Husam Hebaishi</small>
          </p>
        </section>
        <section>
          <h3>About me</h3>
          <ul>
            <li>Started playing with C++ as a teenager</li>
            <li>Engineering lead at VCA Technology Ltd.</li>
            <li>Working on a full-stack video analytics application</li>
            <li>Big fan of CMake + conan</li>
          </ul>
        </section>
        <section>
            <h2>Stringification in Python</h2>
            <pre><code class="python" data-trim data-line-numbers>
my_container = [1, 2, 3]
print(my_container)
            </code></pre>
            <p class="fragment">Output:</p>
            <pre class="fragment"><code class="nohighlight" data-trim>
[1, 2, 3]
            </code></pre>
        </section>
        <section>
            <h2>Stringification in Python</h2>
            <pre><code class="python" data-trim data-line-numbers>
                my_container = [1, 2, 3]
                my_container.append({
                  "hello": "world",
                  1: 2
                })
                print(my_container)
            </code></pre>
            <p class="fragment">Output:</p>
            <pre class="fragment"><code class="nohighlight" data-trim>
[1, 2, 3, {1: 2, 'hello': 'world'}]
            </code></pre>
        </section>
        <section>
            <h2>Stringification in Python</h2>
            <pre><code class="python" data-trim data-line-numbers="6">
                my_container = [1, 2, 3]
                my_container.append({
                  "hello": "world",
                  1: 2
                })
                print(my_container)
            </code></pre>
            <p class="fragment">The print statement is quite magical!</p>
        </section>
        <section>
          <h3>But what about C++?</h3>
        </section>
        <section>
          <h3>Stringification in C++</h3>
          Let's look at a similar example
            <pre><code class="cpp" data-trim data-line-numbers>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector &lt;int&gt; my_container = {1, 2, 3};
  std::cout &lt;&lt; my_container;
  return 0;
}
            </code></pre>
            <p class="fragment">No, that doesn't work...</p>
            <p class="fragment">Ok, let's implement a stringification function</p>
        </section>
        <section>
          <h3>Stringification in C++</h3>
          Our stringify function v1.0:
          <pre><code class="cpp" data-trim data-line-numbers>
std::string stringify(const std::vector&lt;int&gt;& cont) {
  std::stringstream ss;
  ss &lt;&lt; "{";
  if (!cont.empty()) {
    ss &lt;&lt; *cont.begin();
    for (auto it = ++cont.begin() ; it != cont.end() ; it++)
      ss &lt;&lt; ", " &lt;&lt; *it;
  }
  ss &lt;&lt; "}";
  return ss.str();
}
          </code></pre>
        </section>
        <section>
          <h3>Stringification in C++</h3>
          So, we add our stringification function
          <pre><code class="cpp" data-trim data-line-numbers>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

std::string stringify(const std::vector&lt;int&gt;& container);

int main() {
  std::vector &lt;int&gt; my_container = {1, 2, 3};
  std::cout &lt;&lt; stringify(my_container);
  return 0;
}
              </code></pre>
              <p class="fragment">Ok, given our previous implementation,</p>
              <p class="fragment">We get:</p>
              <pre class="fragment"><code class="nohighlight" data-trim>
{1, 2, 3}
              </code></pre>
        </section>
        <section>
          <h3>Stringification in C++</h3>
          <pre><code class="cpp" data-trim>
            std::string stringify(const std::vector&lt;int&gt;& container);
          </code></pre>
          So, we're done.
          <p class="fragment">Right?</p>
          <p class="fragment">No.</p>
        </section>
        <section>
          <h3>Stringification in C++</h3>
          <p>What if we have a <code>std::set&lt;int&gt;</code>?</p>
          <p class="fragment">Easy, stringify becomes a template!</p>
        </section>
        <section>
            <h3>Stringification in C++</h3>
            Our new stringify function v1.1:
            <pre><code class="cpp" data-trim data-line-numbers="1-3">
  template
  &lt;typename T&gt;
  std::string stringify(const T& cont) {
    std::stringstream ss;
    ss &lt;&lt; "{";
    if (!cont.empty()) {
      ss &lt;&lt; *cont.begin();
      for (auto it = ++cont.begin() ; it != cont.end() ; it++)
        ss &lt;&lt; ", " &lt;&lt; *it;
    }
    ss &lt;&lt; "}";
    return ss.str();
  }
            </code></pre>
        </section>
        <section>
          <h3>Stringification in C++</h3>
          <pre><code class="cpp" data-trim data-line-numbers>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;

template &lt;typename T&gt;
std::string stringify(const T& container);

int main() {
  std::set &lt;int&gt; my_container = {1, 2, 3};
  std::cout &lt;&lt; stringify(my_container);
  return 0;
}
          </code></pre>
          <p class="fragment">Are we done yet?</p>
          <p class="fragment">Sadly not...</p>
        </section>
        <section>
          <h3>Stringification in C++</h3>
          What about the following types:
          <pre><code class="cpp" data-trim data-line-numbers>
std::vector&lt;std::set&lt;int&gt;&gt; c1;   // Nested container
std::map&lt;int, std::set&lt;int&gt;&gt; c2; // Map - contains pairs
std::tuple&lt;int, std::string&gt; c3; // Don't get me started!
          </code></pre>
          <p class="fragment">We might need to specialize <code>stringify</code> a bit.</p>
        </section>
        <section>
          <h3>Stringification in C++</h3>
          <p class="fragment">Let's take a step back.</p>
          <p class="fragment">What we need is something <strong>generic</strong></p>
          <p class="fragment">So we can stringify all the types listed previously</p>
          <p class="fragment">And not have to keep specializing <code>stringify</code></p>
          <p class="fragment">Enter <strong><code>easyprint</code></strong>!</p>
        </section>
        <section>
          <h3>easyprint - What is it?</h3>
          <ul>
            <li class="fragment">A C++11 template header</li>
            <li class="fragment">Allows easy stringification of STL containers</li>
            <li class="fragment">Supports complex/nested types</li>
          </ul>
        </section>
        <section>
            <h3>easyprint - How do I use it?</h3>
            <pre><code class="cpp" data-trim data-line-numbers>
#include &lt;easyprint.hpp&gt;
easyprint::stringify(mycontainer);
              </code></pre>
              And that's it!
        </section>
        <section>
          <h3>easyprint</h3>
          <pre><code class="cpp" data-trim data-line-numbers>
std::vector&lt;std::set&lt;int&gt;&gt; c1 = {
  {1,2,3},
  {4,5,6}
};
std::map&lt;int, std::set&lt;int&gt;&gt; c2 = {
  {1, {2, 3, 4}},
  {3, {4, 5, 6}}
};
std::vector&lt;std::tuple&lt;int, std::string&gt;&gt; c3 ={
  {1, "Hello"},
  {2, "World" }
};
print(c1); print(c2); print(c3);
          </code></pre>
          <p class="fragment">Output:</p>
          <pre class="fragment"><code class="nohighlight" data-trim>
{{1, 2, 3}, {4, 5, 6}}
{{1, {2, 3, 4}}, {3, {4, 5, 6}}}
{{1, "Hello"}, {2, "World"}}
          </code></pre>
        </section>
        <section>
          <h3>easyprint</h3>
          We're back where we started:
          <pre><code class="cpp" data-trim data-line-numbers="13">
            std::vector&lt;std::set&lt;int&gt;&gt; c1 = {
              {1,2,3},
              {4,5,6}
            };
            std::map&lt;int, std::set&lt;int&gt;&gt; c2 = {
              {1, {2, 3, 4}},
              {3, {4, 5, 6}}
            };
            std::vector&lt;std::tuple&lt;int, std::string&gt;&gt; c3 ={
              {1, "Hello"},
              {2, "World" }
            };
            print(c1); print(c2); print(c3);
            </code></pre>
            <p class="fragment">And <strong>now</strong> we're done.</p>
        </section>
        <section>
          <h3>easyprint</h3>
          <p>You can find easyprint here:</p>
          <p>https://github.com/hebaishi/easy-cpp-print</p>
          <p class="fragment">Thank you for listening!</p>
        </section>
      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        transition: 'none',
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true }
        ]
      });
    </script>
  </body>
</html>
